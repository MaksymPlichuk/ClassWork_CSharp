C# conspect 
--------------------------------------------------------------
				-01_IntroToDotNet-
C++  некерований додат
C#  керований  працює на .NET

середовище виконання (CLR)comand language runtime
менеджер між класами бібліотеками ОС, дає і очищає пам'ять

C# - чисто ООП
static - не міняє this  викликається черз .
esc методи - endl,\n

cw + Tab / Console.WriteLine("Hello")

Unsigned - перекидало з - да +


ввід данних cin
Console.WriteLine("Enter nubmer: ");

string str = Console.ReadLine()!;  !- прибирає зелену звильку
Console.WriteLine(str + "!!!!!!");


int number = int.Parse(str); int.Parse(str) - перетвор на int/любий тип
Console.WriteLine(number + 10 + "!!!!!!");


Console.WriteLine($"You entered: {number + 100} !!!!!");
$ - інтерполяція  дозволяє додати

великі типи данних - heap

DateTime now DateTime.Now;	//вказт час
Console.WriteLine(now);

int? num2 = null; ? - вказівник

if (str != null)
str. ToUpper();
//or  те саме 	? -> not null
str?.ToLower

C# Data Types
...

--------------------------------------------------------------
					-Static-
статичні змінні створ один раз на початку програми
статичні змінні одні для всіх
статичні ф-ціх створ одна для всіх

--------------------------------------------------------------
					-02_Arrays-
int 16 short
int 32 - int
int 64 long

var - те саме що й auto
arr5.SetValue(77, 2);
arr5.SetValue(77, 4);
foreach (var elem in arr5)
{ Console.WriteLine(elem + " "); }



		MAtrix(Двовимірний масив)
		
int[,] array = new int[3, 3]; [3, 3]; 3 рядка 3 колоники
int[,] - масив двовимір
int[] - масив одноимір

int[,] array2 = new int[3,4];
Console.WriteLine(array2.Length);



for (int i = 0; i < array2.GetLength(0); i++)
{
	for (int j = 0; j < array2.GetLength(1); j++)
		{array2[i, j] = i *j + 1;}
}



		Трьох вимірний масив int[,,]
		
int[,,] array = new int[3, 3, 3];
array[0, 0, 0] = 1;
array[0, 0, 1] = 2;



for (int i = 0; i < array.GetLength(0); i++)
for (int j = 0; j < array. GetLength(1); j++)
for (int k = 0; k < array.GetLength(2); k++)


Console.Write(array2[i, j, k]);


Console.ReadKey(); - затримка монітора
//передив static


Array.Resize(ref myArn2, 5); ref-вказ на оригінал
Array.Rank - вказ якого виміру масив
--------------------------------------------------------------
					-03_StringBuilderString-
string[] array = { "Hello", "From", "Summer", "Sun", "Tree", "Lake" };					


					
string.Join(obj,array)   -> приєднує все в 1 рядок і додає obj				



string message = string. Join(" - ", array);
Console.WriteLine("My message: " + message + 10);



//ділитть текст на масив із слів
string []words = htmlMessage.Split(new char[] {'','','','','?' }
				StringSplitOptions.RemoveEmptyEntries);

	StringSplitOptions.RemoveEmptyEntries // видаляє пробіли



	Console.WriteLine("Count of words: " + words.Length);
	foreach (string s in words){
		Console.WriteLine(s);
		}
		
	ConsoleKeyInfo key = Console.ReadKey(); // ає змогу ввести клавішу
	if(key.Key == ConsoleKey.F12){
		Console.WriteLine("F12 - Have a nice day!")
		}



тип данних decimal заокруглює до більшого після коми, підходить для грошей
decimal money = 41.90m;



CultureInfo us = new CultureInfo("en-US") - вказ тип валюти



string course = $"Todays course: {money.ToString("C2",us)}"
//C2 - к-сть цифр після коми 	us - регіон



str?.toLower  -> якщо str!=null 
nullStr?.Tolower()-> null condition operator 



	--string методи валідації--

string.IsNullOrEmpty(nullStr) && string.IsNullOrWhiteSpace(str2)
	перевіряє чи пусто або null        перевіряє на null або пробіли 	 дають true


	
string.Compare(str1,str2) - повертає 0 якщо рядки рівні

str1.Contains("Test") - повертає true якщо знайдено входження 'Test'

string substr = str4.Substring(23)	//витягує все починаючи з 23 індекса 



	--String interpolations--

string result = String.Format("Number: {0:d4}", number); 			//(Number: {0}, number) -> підстав у {0} number
            Console.WriteLine(result); 								// виведе 0024
	
	
		long number4 = 19876543210;
        string result5 = String.Format("{0:+# (###) ###-##-##}", number4);
				або
        string result6 = $"{number4:+# (###) ###-##-##}";
        Console.WriteLine(result5); // +1 (987) 654-32-10

		
Console.WriteLine($"Name: {"Ivan",-10} Age: {23,10}"); 				// -10 резервує 10 комірок по лівому краю
Console.WriteLine($"Name: {"Veronika",-10} Age: {34,10}");  		// +10 по правому краю



string s11 = "hello world";
            char ch = 'o';
            int indexOfChar = s11.IndexOf(ch); 						// повертає індекс першого входження (4)
            Console.WriteLine(indexOfChar);

            string subString = "wor";
            int indexOfSubstring = s11.IndexOf(subString); 			// повертає індекс першого входження (6)
            Console.WriteLine(indexOfSubstring);



Якщо рядок буде постійно доповнюватись то string буде не оптимізованим
і краще буде використати StringBuilder -> працює так само як і вектор

--------------------------------------------------------------
					-04_IntroToOOP-

class - потрібен коли складний тип данних


	internal - дає доступ до класу лише в межах цієї збірки(04_IntroToOOP)
	protected internal - те саме що і protected + internal 


Ініціалізувати змінні краще у конструкторі, ОКРІМ констант

				
class ChildClass: Point{}											//public inheritance змінити не можна

																	множинне наслідування з звичайними класами - заборонене
	private int xCoord; - тип вказ біля кожної змінної
	private int yCoord;

Point @class = new Point(); @ - об назвати об'єк ключовим словом



class Point: Object // всі класи автоматично умпадковують object



base - батьківський класс

propety - поля які спрощують geters seters



public int XCoord()
{

	get { return xCoord; }
	set {
		if (newX >= 0)
			xCoord newX;
		else
			xCoord = 0;}	}
	
кулюч - property
куб - метод


propfull + Tab --> fullproperty - можна робити перевірку

prop + Tab --> auto property



partial class Point{} -> щоб створити 2 класи з однією назвою
розбиит класс на частини

static int model; - static один для всіх

--------------------------------------------------------------
					-05_StructRefOut-

property - властивість яка робить змінну контрольовану(всередині є seter який має валідацію)
	

	
struct - stack
class - heap



static void MethodWith__(string name, params int[] marks){}

params - дає змогу ініціалізвуати через initializer list (мають завжди бти останнім параметром)



MethodWith__("Pedro", new int[]{656,9,65,1456,654,48})
MethodWith__("Bob", 11,111,11,15,2,13,153,51) - замість 9 аругментів params перетворює на 2 string name і int[] marks


те саме в C++ без params: MethodWith__("Bob", {11,111,11,15,2,13,153,51} )

		
для предачі оригіналу на c++ 
static void Modify(int &num, string &str, Point& point)	
	на C#		
static void Modify(ref int num, ref string str, ref Point point)



ref = &
(зберігає адресу але напряму дозволяє доступатися до оригіналу
передає адресу дозволяє доступатися до оригіналу)



Point point = new Point() { X=10, Y=15 } - ініцілаізація без параметриз до ctor



value - копія значення
reference - копія адреси



out - те саме щой ref (працюють з оригіналом)
static void GetCurrentTime(out int hour, out int minute, out int second)
{hour = DateTime.Now.Hour; minute = DateTime.Now.Minute;
		second = DateTime.Now.Second;}
	
	
ref - дозволяє змінити тільки ініалізовану змінну
out - може працювати без ініцілізованої змінної
	(створений для початкової ініціалізації +переревіряє чи всі змінні ініціалізовані)


в більшості, new - create dynamic memory
в struct, new - invoke(виклик) default constructor

--------------------------------------------------------------
					-06_Exception-
sinlge = float


створити власний exception: throw new DivdieByZeroExceptio("Second operant = 0")


створюємо - щоб конкретизувати помилку

try - перевіряє код 
catch - ловить помилку винкиає не завжди
finally	- запускається без умовно,  записуємо
	коли треба закрити, почистити незалежно від exception


finally - блок використовується щоб завжди зпрацювати

checked - перевіряє чи є місце в комірці якщо нема то буде exception (byte+100=255)+ exception
unchhecked - ігнорує overflow (byte+100=0)

namespace - можливість створити класи з однаковою назвою але різним функціоналом				

	https://github.com/IliushynOlena/Exceptions
    https://github.com/IliushynOlena/c_charp_namespaces

--------------------------------------------------------------
					-07_OverloadOperators-

static - не має this, викликаємо без екземпляру класу


public static return_type operator [symbol](parameters )
	
public static Point operator -(Point point) 			//створ новий об'єкт який повертаємо
{ Point res = new Point {
	X = -point. X,
	Y = -point. Y};
	return res;
}


public static Point operator ++(Point point)			//міняє оригінал
{														//перезавантає зразу префіксна і постфіксна форма але
    point.X++;											//працюють вони як префіксна
    point.Y++;
    return point;
}


public static Point operator +(Point p1, Point p2)		//перезавантаж p1+p2
        {
            Point res = new Point
            {
                X = p1.X + p2.X,
                Y = p1.Y + p2.Y
            };
            return res;
        }


public static bool operator <(Point p1, Point p2)
	{
		return p1.X + p1.Y < p2.X + p2.Y;
	}
	

public static bool operator true(Point p)
	{
		return p.X != 0 || p.Y != 0;
	}
//приклад застосування
if (p1) { Console.WriteLine("P1 is True"); }
    else { Console.WriteLine("P1 is False"); }
	
	
b = a;			//int ---> double 5.0000000 implicit (неявно)
a = (int) b;	//double  --> int 5  explicit  (явно)


public static implicit operator int(Point p)		//перетвор Point на int (неявно)
  {													// b = p1
      return p.X+ p.Y ;
  }
 

public static explicit operator _3D_Point(Point p)	// перетвор від Point -> _3D_Point
        {											//explicit (явно)
            return new _3D_Point(p.X, p.Y, 100);
        }

 _3D_Point newPoint = (_3D_Point) p1;	//Point ---> _3D_Point
 _3D_Point newPoint = (_3D_Point) p1
 
--------------------------------------------------------------
					-08_InheritanceIndexers-

в C# множинне наслідування заборонене (крім інтерфейсів)


new DateTime();  -  save 01.01.0001

			
new - create new member and stop virtual	//працюватиме батьківська ф-ція зупиняє поліморфізм
	
	
abstract class Person  (завжди є наслідником Object) - абстрактний класс (не можна створювати обєкт)
//abstract method the same  void DoWork() = 0;
		
	public abstract void DoWork();
			- асбтрактний метод (пустий де немає ніякої реалізації)

abstract class - для наслідування


sealed - забороняє перевизначати наслідниками цього методу, або забороняє наслідування классу


property - віртуальними не бувають


механізм пізнього звязування - на моменті компіляції визначається який метод буде використаний

Механізм пізнього зв'язування (Late Binding) у C# — це можливість викликати методи або отримувати властивості 
об’єкта під час виконання програми (runtime), а не під час компіляції (compile-time). 
У C# пізнє зв’язування реалізується через ключове слово dynamic або інтерфейс System.Reflection


indexator - [] можна перезавантажити по всіх property полях які є в класі


 public Laptop this[int index]			//перезавантаж по індексу
        {
            get
            {
                if (index >= 0 && index < laptops.Length)
                {
                    return laptops[index];
                }
                throw new IndexOutOfRangeException();
            }
            set
            {
                if (index >= 0 && index < laptops.Length)
                {
                    laptops[index] = value;
                }
            }
        }

 public Laptop this[string name]		//перезавантаж по імені
        {
            get 
            {
                foreach (var l in laptops)
                {
                    if(l.Model == name)
                        return l;
                }
                return null;
            }  

--------------------------------------------------------------
					-09_Interfaces-
					
інтерфейси - в c++ абстрактні класи(методи без реалізації)


інтерфейс -клас всередені якого запис пусті методі проперті 
івенти і всі вони public 										// називаються з I
	всередині пропис прототипи методів без їх реалізації


коли класи наслідують інтерфейси з являється імплементація
	(обіцяю написати реалізацію  для всіх методів які прийдуть)

Інтерфейси - не наслідуються а імплементуються


без override ToString покаже назву проекта

base.Print() -> те саме що й Human.Print()


class Director: Employee, IManager	//implement / realize
{}


IManager director = new Director		//інтерфейсне посилання
	//дає доступ тільки до тих методів що є в інтерфейсі

(director as Director)!. Salary = 30000000; 	//поміняти інтерфейсрне посилання 
	//дає доступ тільки до всіх методів класу


інтерфейсрне посилання - можна вказати об'єкту якщо класс імплементує цей інтерфейс

--------------------------------------------------------------
					-10_StandartInterfaces-
					
композиція - один об'єкт є невідє'мною частиною іншого


class Auditory : IEnumerable	//імплементуємо smartpointer 
										для foreach

public IEnumerator GetEnumerator()
	{
		return students.GetEnumerator();
	}

foreach (Student st in auditory)	//в auditory немає smartpointer по дефолту
{
	Console.WriteLine(st.ToString());
}


	--для методу Array.Sort()--

class Student : IComparable<Student>

public int CompareTo(object? obj)			//для методу array.Sort()
	{
	 if( obj is Student)
	{
		return this.FirstName.CompareTo((obj as Student)!.FirstName);
	}
else
{
throw new Exception("Er")]


		порівняння для любого поля Student
public void Sort (IComparer<Student> comparer)	//імлементуємо IComparer<Student> депишемо реалізацію
	{
	 Array.Sort(students, comparer);
	}


class BirthdateComparer : IComparer<Student>		//як тут імплементуємо IComparer<Student>
    {
        public int Compare(Student? x, Student? y)
        {
            return x!.Birthdate.CompareTo(y!.Birthdate);
        }

auditory.Sort(new BirthdateComparer());
	foreach (Student st in auditory)
	{
	 Console.WriteLine(st.ToString());
	}
	
	
			---Клонування--- Iclonable
			
власні типи данних - глибоке копіювання			
			
			
public object Clone()
	{
		Student temp = (Student)this.MemberwiseClone();		//shallow copy
		
		//плибоке копіювання
		temp. StudentCard = new StudentCard()
		  {
		Number = this. StudentCard. Number,
		Series = this. StudentCard. Series 
		  };
		return temp;
	}
	
	
enum - набір чилочисельних констант

 enum DayOfWeek				//const int Monday = 0;
    {
        Monday, Tuesday, Wednesday, Thursday, Friday, Saturday, Sunday
    }

	виведнення значення  і його
foreach (Discount item in values)
	{
	 Console.WriteLine($"{item} - {(int)item}");
	}
	
--------------------------------------------------------------
					-11_Delegates-
					
Делегат — це тип, який представляє метод з певною сигнатурою. 
	Можна зберігати методи у змінних і викликати їх пізніше. Делегати дуже схожі на вказівники на функції у C++.
	
Делегат - вказівник на функцію(силочний тип який дозволяє зберігати		//основа віконних додатків
				посилання на методи або ф-ції заданої сигнатури(тип поврнення, аргумент який передав))
							
readonly property - property який має тільки get


	MultycastDelegate - можливість записати на delegat декілька адреси


 ---
 public delegate double DoubleDelegate(); // створ делегат(як класс)


 class SuperClass
    {
		public static double GetKoef() 		//делегат орієнтується по типу данних(double)
			{
				return new Random().NextDouble();
			}
	}
	
	
DoubleDelegate deleg = new DoubleDelegate(SuperClass.GetKoef);		//прив'язуємо GetKoef до делегата
		//or
DoubleDelegate deleg =  SuperClass.GetKoef;		//deleg тепер робить те, що і функція без ()


Console.WriteLine(deleg()); //те саме що//   Console.WriteLine(SuperClass.GetKoef()); 


Print.Invoke 	//те саме що// 	Print()


deleg?.Invoke() 		//? - перевіряє чи null, якщо ні то викликається Invoke




	---на один делегат записати декілька ф-цій---

voidDelegate += superClass.Test

	//or
 DoubleDelegate[] doubleDelegate = new DoubleDelegate[2] {
       SuperClass.GetKoef,
       superClass.GetNumber
  };

   Console.WriteLine(doubleDelegate[0]?.Invoke());
   Console.WriteLine(doubleDelegate[1]?.Invoke());


--Anonymos Delegates, Lambda--

 public delegate int ChangeDelegate(int a); //створ делегат
 
  static void ChangeArr(int[] arr, ChangeDelegate change )
        {
            for (int i = 0; i < arr.Length; i++)
            {
                arr[i] = change(arr[i]);
            }
        }
		
static int Increment(int n)
        {
            return ++n;
        }

main{...
	
			ChangeArr(arr, Increment);
		
		
            //anonymus delegate -------- 2 ---------
			
            ChangeArr(arr, delegate (int n) { return --n; });
			
			
            //lambda expresion  ---------- 3 --------- 
			
            ChangeArr(arr,(n) => --n);
			
			
--------------------------------------------------------------
					-12_Events-

CallBackFunction - ф-ції які викликають в кінці
	передача в метод делегату яуій має запуститися в кінці алгоритму нашого методу
				
public event ExamDelegate - дає публічний доступ через -= +=



event - безпечний делегат який тільки може += і -= зберігає інкапсуляцію			


Якщо подія викликається в конструкторі, то на неї ще ніхто не підписаний, тому нічого не станеться.



Якщо в конструкторі використати: ExcRate = ec:

    Exchange exchange = new Exchange(40, 39, 46);
	
//тому 	Exchange exchange = new Exchange() { MinVal = 39, MaxVal = 46 };
		exchange.ExcRate = 40;
.....


extensions - якщо є бібліотека і нехватає методу і його будемо часто використ



щоб створити розширення class має бути static



static class ExampleExtension
    {
        public static int NumberWords(this string data)		//обов'язково для extension (this string data)
        {
            if(string.IsNullOrEmpty(data)) return 0;		//data інформація від якої приходить алгоритм
            return data.Split(new char[] {' ',',','!'}, 
                StringSplitOptions.RemoveEmptyEntries).Length;
        }
}

--------------------------------------------------------------
					-13_GarbageCollector-		

GarbageCollector - автоматичний механізм управління пам'яттю


Поки на об'єкт є посилання CLR не буде його чистити


GarbageCollector - недетермінований (ми на нього не впливаємо)
	//неможливо знати коли він запуститься



using (FileStream str = new FileStream("Hello.txt", FileMode.Create))
{
//write...read
//ex
}//str.Dispose


всередені using створ об'єкт і виконується IDisposeable який закриває файл


синтакстичний цукор C# - конструкції мови, які спрощують код, роблячи його більш читабельним і лаконічним, 
	але не додають нової функціональності
	
	Методи розширення (Extension Methods)
	Автоматичні властивості (Automatic Properties)
	Лямбда-вирази (Lambda Expressions):
	Рядки, що інтерполюються (String Interpolation)
	Крапка з комою (;) у кінці рядка


				-14_Dictionary-	
				
ключі мають бути унікальними


Dictionary<string, string> countries = new Dictionary<string, string>();
 
    countries.Add("UA", "Ukraine");
	
foreach (KeyValuePair<string,string> country in countries)
            {
                Console.WriteLine($"Key : {country.Key,5}. Value {country.Value,20}");
            }
 
--------------------------------------------------------------
					-15_GenericCollections-	
					
Generics - дозволяють створювати класи, методи, інтерфейси та 
делегати, які працюють з будь-яким типом даних (int, string, float, 
свої класи тощо) без дублювання коду	(ШАБЛЛОНИ)

НЕ generic - стандартні колеції які дає мова програмування


не узагальнені колецкії зберігаються у 		//using System.Collections
		 //(зберігають об'єкти типу данних obj)


	нестардартний Stack stack

	Stack<T> - generic 		Stack - не generic
	
stack - не generic повртає obj

peek - показує на вершині
pop - видаляє останній
push - дає в кінець

---------

boixng - із стат в дин	 stack -> heap

obj - reference тип(heap)


//boxing
obj = (object) number;		//value -> ref
Console.WriteLine(obj);

//unboxing
number = (int)obj;			//ref -> value
Console.WriteLine(number);


не generic - майже не використ


для //unboxing

int res = (int)myClass;

	public static implicit operator int(MyClass p)
	{
		return p.num;
	}

//boxing

MyClass myClass = new MyClass(number);		//value => ref

sortedList - словник у якому елем сортуються по ключам							//приймають і повертають obj
Hashtable -  словник у якому для ключа з'яв хешкод(унікальне знач за GetHashCode)	//не є generic

==Generics==				==НЕ Generics==
	Collection <T>				CollectionBase
	List <T>					ArrayList
	Dictionary <TKey,TValue>	Hashtable
	SortedList <TKey,TValue>	SortedList
	Stack <T>					Stack
	Queue <T>					Queue
	LinkedList <T>				нет


using System.Collections.Generic

	==що може бути Generics==	
	Classes
	Structures
	Collection
	Methods
	Interface
	Delegate
	

//generic Delegate

    public delegate Type SummaDelegateTemplate<Type>(Type a, Type b);	
	
	
//generic Interface

	interface IMyComparable<T> {	//шаблонний інтерфейс
		void CompareMyObject(T obj1, T obj2);
	}


default(Type) - встанов дефолтне знач при любом типу данних 

dynamic - тип визначається на етапі ВИКОНАННЯ


Point point1 = new Point(); 	//new create dynamic memory
Time time = new Time();			//invoke default constructor


CompareTo повертає -1 якщо менше, 0 якщо рівно, +1 якщо більше

--------------------------------------------------------------
					-16_WorkWIthFile-

					
	static void WriteFile(string path)
		{
		
		// де буде створений	режим		для чого			режим спільного використ
		
//FileStream( string path, FileMode mode, FileAccess access, FileShare share)
		
		
	FileStream fileStream = new FileStream("text.txt", 
		FileMode.OpenOrCreate, FileAccess.Write, FileShare.Read)				
			
	}				


					
using ( FileStream fileStream = new FileStream("text.txt", 
	FileMode.OpenOrCreate, FileAccess.Write, FileShare.Read)){
	
	
	//Doing some work...	//filesteam доступний лише в {} using і 
									вкінці викличе fileStream.Dispose()
	
	
	}
	
	
//програма визначає де буде файл		
	
string path = $@"{Environment.GetFolderPath (Environment. SpecialFolder. Desktop)}\text.txt";
WriteFile("Text.txt");
	
ReadAsync - вікно не фризиться робиться без заморозки програми	




 static void WriteFile(string path)
        { using (FileStream fs = new FileStream(path, FileMode.Create, 
                FileAccess.Write,FileShare.None))
            {

                Console.WriteLine("Enter some text : ");
                string writeText = Console.ReadLine();

                byte[] writeBites = Encoding.Default.GetBytes(writeText);
                fs.Write(writeBites,0, writeBites.Length);

                Console.WriteLine("File was recorded!!!!");

            }

		}


 static string ReadFile(string path)
        {
            using (FileStream fs = new FileStream(path, FileMode.Open,
                FileAccess.Read))
            {
                byte[]readBytes = new byte[fs.Length];
                fs.Read(readBytes, 0, readBytes.Length);
                return Encoding.Default.GetString(readBytes);
            }
        }


			=======АБО=======
				
				
 static void WriteTextFormat(string path)
        {
            using (StreamWriter sw = new StreamWriter(path))
            {
			
			
			 Console.WriteLine("Enter some text : ");
             string writeText = Console.ReadLine();

             sw.WriteLine(writeText);
			 
			 
            }
        }
		
 static void ReadTextFormat(string path)
 {
     using (StreamReader sr = new StreamReader(path))
     {

         while (!sr.EndOfStream)
         {
             Console.WriteLine(sr.ReadLine() + "!!!");
         }
		 
     }
 }				


--------------------------------------------------------------
					-17_Attributes-

					
Atributes - додають додаткову інформацію для полів / дають змогу зробити валідацію
		додат компоненти які пишуться над елементами


[Obsolete] - атрибут що означ клас застарілий

[Searializable] - помічає клас що його може сеаріалізувати / 
	процес збереження стану об'єктва в будь якому потоці з можливостю його відновлення (запис у файл)


using System.ComponentModel.DataAnnotations; 	//підключення для атрибутів



[AttributeUsage(AttributeTargets.Method)] - вказ для чого атрибут / де його можна використ 

class CoderAttribute: Attribute{
        public string Name { get; set; } = "Olena";
        public DateTime Date { get; set; } = DateTime.Now;
        public CoderAttribute() { }
        public CoderAttribute(string n, string date) {.....}
		
		 public override string ToString()
        {
            return $"{Name } : {Date}";			//при item.GetCustomAttributes<CoderAttribute>(true)
        }									//буде виводити: Olena 14/07/2025 00:00:00(якщо ф-ця не викликана)
}




[CoderAttribute]	//вказує що у класі використвоується цей атрибут
class Employee{..
	public double  Salary { get; set; }

	[CoderAttribute]	//виклип дефолтний конструктор у класі кодер
	public Employee() { }		//додаэ метаданні до звич конструктора які потім можна вивести
	 
	 [Coder("Dima","2025-07-14")]
    public void IncreaseSalary(double sum)
    {
        Salary += sum;
    }
..}


 Console.WriteLine("Attributes of members of class Employee");
            foreach (MemberInfo item in typeof(Employee).GetMembers())
            {
                Console.WriteLine("\t" + item.ToString());
                foreach (var attr in item.GetCustomAttributes<CoderAttribute>(true)) //виводить атрибути у item
                {														// атрибут доповним клас додатковою 
                    Console.WriteLine("\t\t" + attr);						// прихованою інформацією
                }
            }




Сеарилізація об'єктів - бінарний формат/
		об'єкт може бути перетворений у потік байтів (серіалізований) 
	для зберігання або передачі, а потім відновлений з цього потоку (десеріалізований) - запис у XML/JSON


//Binary serialize

	[Serializable] 		//познач що файл можна записати
	
    public class Person
    {
        public Passport Passport { get; set; }....
	}



		BinaryFormatter formatter = new BinaryFormatter();

			

			using (Stream fstream = File.Create("Persons.bin"))		//записує
					{
						formatter.Serialize(fstream, persons);
					}
		Console.WriteLine("BinaryFormatter is OK!!!");


		Person p = null;
				using (Stream fsStream = File.OpenRead("test.bin"))		//зчитує
				{
					p = (Person)formatter.Deserialize(fsStream);
				}
		   


//XML JSON > Binary  бо не треба додавати атрибут [Serializable]
	XML JSON - працюють з приватними змінними	//Бінарно - через проперті


//XML serialize


		XmlSerializer xmlSerializer = new XmlSerializer(typeof(List<Person>));
          
          
              using (Stream fs = File.Create("persons.xml"))
              {
                  xmlSerializer.Serialize(fs, persons);
              }
              Console.WriteLine("XmlSerializer is OK!!!");
          
          

			List<Person> newPersons = null;
			
			
			using (Stream fstream = File.OpenRead("persons.xml"))
			  {
				  newPersons = (List<Person>)xmlSerializer.Deserialize(fstream);
			  }
			  
          foreach (var item in newPersons)
          {
              Console.WriteLine(item);
          }


//JSON serialize 

            List<Person> persons = new List<Person>()
            {
              new Person(123654){ Name="Jack", Age = 15},
              new Person(123654){ Name="Tom", Age = 12},
              new Person(123654){ Name="Bill", Age = 35},
              new Person(123654){ Name="John", Age = 47}
            };
            string fileName = "Person.json";
            string jsonString = JsonSerializer.Serialize(persons);
            File.WriteAllText(fileName, jsonString);


//Зчитування

            List<Person> newPersons = null;
			
            jsonString = File.ReadAllText(fileName);
			
            newPersons = JsonSerializer.Deserialize<List<Person>>(jsonString)!;
         
            foreach (var item in newPersons)
            {
                Console.WriteLine(item);
            }




[Required] - обов'язкове поле


DataAnotation або Atribbute - перевіряють проперті на правельність


[Required(ErrorMessage ="Name not setted")]
[StringLength(50, MinimumLength =3, ErrorMessage = "Wrong lenght")]

public string Name { get; set; }	//атрибути на проперті



https://github.com/IliushynOlena/PD411_CSharp/blob/master/17_01_Attributes/Program.cs
https://github.com/IliushynOlena/PD411_CSharp/blob/master/17_2_BinarySerialize/Program.cs
https://github.com/IliushynOlena/PD411_CSharp/blob/master/17_3_XML_JsonSerialization/Program.cs
https://github.com/IliushynOlena/PD411_CSharp/blob/master/17_4_DataAnnotations/Program.cs


--------------------------------------------------------------
					-18_RegularExpressions-
Створити  Regex - віладація


string pattern2 = @"\D+";
	
	
 Regex regex2 = new Regex (pattern2);	
	regex2.IsMatch(str2) 	// перевірка чи підїодить str2 (true/false)
	
	
	
string value = "4 - 5 AND 5 y 578";
	
	
  Match m = Regex.Match(value, @"\d");
	 if(m.Success)
            {
                Console.WriteLine(m.Value);		//якщо виходить виводить результат
				Console.WriteLine(m1.Index);	//індекс з якого співпадіння
                Console.WriteLine(m1.Length);	//довжина співпадіння
            }
	
	
string value1 = "saidsaid said shed shed see sprear spread super";
	
	
        MatchCollection coll =  Regex.Matches(value1, @"s\w+d");	//робить колекцію з записів що підійшли
			foreach (Match match in coll)
            {
                Console.WriteLine($"Index = {match.Index}. Value : {match.Value}");		
            }
			

      string output1 = Regex.Replace(value1, "s.+d", "white");		//заміняє всі слова що почин на 's' і закінч на 'd'
           Console.WriteLine(output1);
	
	
сайт для Regex: https://saschadens.github.io/
	
	
	
	СПЕЦ. СИМВОЛИ
        \d - Визначає символи цифр. 
        \D - Визначає любий символ, який не є цифрою. 
        \w - Визначає любий символ цифри, букви або нижнє підкреслення. 
        \W - Визначає любий символ, який не є цифрою, буквою або нижнім 
             підкресленням.. 
        \s - Визначає любий недрукований символ, включаючи пробіл. (таб і 
             перехід на новий рядок)
        \S - Визначає любий символ, крім символів табуляции, нового рядка 
             и повернення каретки.
        .  - Визначає любий символ крім символа нового рядка.  
				

		\. Крапки
		\w Слова
		\s Пробіли
		\/ Слеши
		
		. - будь який символ
	
	
	Квантифікатори
			
            ^ - з початку рядка. 
            $ - з кінця рядка. 
            * - 0 і більше входжень підшаблону в сторці.  
            + - 1 і більше  входжень підшаблону в сторці.  
            ? - 0 чи 1  входження підшаблону в сторці. 
	

[^@\s] 		//gsor(^) в квадратних дужках ВКАЗУЄ ЩО НЕВХОДИТЬ


				
 ^\w{3,}\@\w+\.\w+$  	//Весь рядок				
 
 @"s\w+d" - поч на s закінчна d
 
 
--------------------------------------------------------------
					-19_LINQ-

LINQ - працюють з копіями
	набір методів які працють з любими типами данних
	
 мова інтегрованих запитів які дають набір методів для роботи 
									з колекціями будь якого типу


			
процес відкладеного завантаження - (як оптимізація)
			 колекція формуєтсья коли її використовують					
					

	/*Синтаксис запиту */
int[] arr = 5, 34, 78, 25, 46, 96, 23};


	//var query from i in arr select i;
IEnumerable<int> query = from i in arr select i*-1;

	
functor - метод який дає інструкцію
	
var res2 = arr.Select(SelectInt)
	
foreach (var item in res2)
{
	Console.Write(item + " ");
}
	Console.WriteLine();
	

LINQ - для отрнимання первної інформації з колеції





			/*Синтаксис запиту */
 var Query = from i in arrint where i% * 2 == 0 select i * -1;                              


			/*Синтаксис методу */
 Query = arrInt. Where(item => item % 2 0).Select(i=>i*-1);


								//return if 
var result2 = words. Where(word => word.Length == 4);





				/*Сортування*/
				
int[] arrInt2 { 15, 7, 8, 9, 12, 14, 78, 95, 36, 15 };


var sortedQuery from i in arrInt2
			where i%2 == 0
			orderby i descending //ascending(default)
			select i;
			
var sortedQuery2 = arrInt2.Where(i=> i% * 2 = 0 )
							.OrderByDescending(i=>i);
							
							
							

int[] arrGroup { 5, 34, 65, 12, 94, 42, 365 };
 var queryGroup from 1 in arrGroup
					where i > 10
					group i by i % 10;

		
	foreach (IGrouping<int, int> item in queryGroup)
	{
	Console.Write(item. Key + " ");
		foreach (var elem in item)
		{
		Console.Write(elem+ " ");
		}
	Console.WriteLine();
	}
	

count average sum min max -
			на основі багатьох елементів повернуть результат
											(а не колекцію)
				

string[] soft = { "Blue", "Grey", "Yellow", "Cyan", "Grey", "Yellow" };
string[] hard = { "Yellow", "Magenta", "White", "Blue" };
IEnumerable<string> result3;	

	
result3 = soft. Except(hard); 		(Grey,Cyan)
			//показує унікальні елементи в soft яких нема в hard
			
			
result3 = soft. Intersect(hard);	(Blue,Yellow)
			// показє спільні елементи
			
			
--------------------------------------------------------------
					-20_UML-
			
UML - unified modeling language		//уніфікована мова програмування (набір різних діаграм)

	найчастіші діаграми:

use case diagram - зображує взаємодію між actor і діями

class diagram

діаграма алгоритмів

	сайти для діаграм
	
https://online.visual-paradigm.com/drive/#proj=0&dashboard

https://app.diagrams.net/


			
			
			
			
			